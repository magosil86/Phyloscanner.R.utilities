ans
infile.inference	<- "~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run/todi_pairs_181006_cl25_d50_prior23_min30_phylogeography_core_inference_mcmc.rda"	#
	outfile.base		<- gsub('.rda$','',gsub('_core_inference','',infile.inference))#
	load(infile.inference)#
	#	thin MCMC output#
	tmp			<- seq.int(2, nrow(mc$pars$Z), mc$sweep)#
	mc$pars$S	<- mc$pars$S[tmp,,drop=FALSE]#
	mc$pars$Z	<- mc$pars$Z[tmp,,drop=FALSE]#
	mc$pars$PI	<- mc$pars$PI[tmp,,drop=FALSE]#
	mc$pars$N	<- mc$pars$N[tmp,,drop=FALSE]#
	gc()#
	colnames(mc$pars$S)	<- paste0('S-',1:ncol(mc$pars$S))#
	colnames(mc$pars$Z)	<- paste0('Z-',1:ncol(mc$pars$Z))#
	colnames(mc$pars$PI)<- paste0('PI-',1:ncol(mc$pars$PI))#
	colnames(mc$pars$N)	<- 'N'#
	##
	#	prepare data.table of proportions#
	dc[, REC_COMM_TYPE:= as.character(factor(substr(REC_COMM_NUM_A,1,1)=='f', levels=c(TRUE,FALSE), labels=c('fisherfolk','inland')))]#
	dc[, TR_COMM_TYPE:= as.character(factor(substr(TR_COMM_NUM_A,1,1)=='f', levels=c(TRUE,FALSE), labels=c('fisherfolk','inland')))]#
	mcpi	<- as.data.table(mc$pars$PI)#
	mcpi[, IT:= seq.int(2, by=100, length.out=nrow(mcpi))]#
	mcpi	<- melt(mcpi, id.vars='IT', variable.name='COUNT_ID', value.name='PI')#
	set(mcpi, NULL, 'COUNT_ID', mcpi[, gsub('([A-Z]+)-([0-9]+)','\\2',COUNT_ID)])#
	set(mcpi, NULL, 'COUNT_ID', mcpi[, as.integer(COUNT_ID)])#
	tmp		<- subset(dc, select=c(REC_COMM_NUM_A, REC_SEX, REC_COMM_TYPE, REC_INMIGRATE, TR_COMM_NUM_A, TR_SEX, TR_INMIGRATE, TR_COMM_TYPE, TR_OBS, COUNT_ID))#
	mcpi	<- merge(tmp, mcpi, by='COUNT_ID')#
	qs		<- c(0.025,0.25,0.5,0.75,0.975)#
	qsn		<- c('CL','IL','M','IU','CU')
z		<- copy(mcpi)#
	#	reset to complex migration status#
	set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
	tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
	set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
	set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
	set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
	tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')]#
	set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
	set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')	#
	tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')]#
	set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
	set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
	tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
	set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
	set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')					#
	set(z, z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')], 'TR_INMIGRATE', 'resident')#
	set(z, z[, which(TR_INMIGRATE=='inmigrant_from_external')], 'TR_COMM_TYPE', 'external')
z
z		<- z[, list(PI=sum(PI)), by=c('REC_COMM_TYPE','TR_COMM_TYPE','TR_INMIGRATE','TR_SEX','REC_SEX','IT')]#
	z		<- z[, list(P=qsn, Q=unname(quantile(PI, p=qs))), by=c('TR_COMM_TYPE','TR_INMIGRATE','TR_SEX','REC_COMM_TYPE','REC_SEX')]#
	z		<- dcast.data.table(z, TR_COMM_TYPE+REC_COMM_TYPE+TR_INMIGRATE+TR_SEX+REC_SEX~P, value.var='Q')
z
z[, LABEL:= paste0(round(M*100, d=1), '%\n[',round(CL*100,d=1),'% - ',round(CU*100,d=1),'%]')]#
	z[, LABEL2:= paste0(round(M*100, d=1), '% (',round(CL*100,d=1),'%-',round(CU*100,d=1),'%)')]#
	setkey(z, TR_COMM_TYPE, REC_COMM_TYPE, TR_INMIGRATE, TR_SEX )#
	z[, STAT:='joint3']#
	z[, DUMMY:= seq_len(nrow(z))]#
	ans		<- copy(z)
ans
groups	<- data.table(	TR_COMM_TYPE=c('inland','inland','fisherfolk','fisherfolk','external','inland','inland','fisherfolk','fisherfolk','external'), #
							TR_INMIGRATE=c('resident','outmigrant','resident','outmigrant','inmigrant_from_external','resident','outmigrant','resident','outmigrant','inmigrant_from_external'),#
							TR_SEX=c('M','M','M','M','M', 'F','F','F','F','F'))
ii<- 1
z		<- copy(mcpi)				#
				#	reset to complex migration status#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')	#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')					#
				set(z, z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')], 'TR_INMIGRATE', 'resident')#
				set(z, z[, which(TR_INMIGRATE=='inmigrant_from_external')], 'TR_COMM_TYPE', 'external')#
				z		<- subset(z, TR_COMM_TYPE==groups$TR_COMM_TYPE[ii] & TR_INMIGRATE==groups$TR_INMIGRATE[ii] & TR_SEX==groups$TR_SEX[ii])
z
z		<- z[, list(PI=sum(PI)), by=c('REC_COMM_TYPE','REC_SEX','IT')]
z
z		<- z[, list(REC_COMM_TYPE=REC_COMM_TYPE, REC_SEX=REC_SEX, PI=PI/sum(PI)), by=c('IT')]				#
				z		<- z[, list(P=qsn, Q=unname(quantile(PI, p=qs))), by=c('REC_COMM_TYPE','REC_SEX')]
z
groups	<- data.table(	TR_COMM_TYPE=c('inland','inland','fisherfolk','fisherfolk','external','inland','inland','fisherfolk','fisherfolk','external'), #
							TR_INMIGRATE=c('resident','outmigrant','resident','outmigrant','inmigrant_from_external','resident','outmigrant','resident','outmigrant','inmigrant_from_external'),#
							TR_SEX=c('M','M','M','M','M', 'F','F','F','F','F'))#
	z		<- lapply(1:nrow(groups), function(ii)#
			{				#
				z		<- copy(mcpi)				#
				#	reset to complex migration status#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')	#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')					#
				set(z, z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')], 'TR_INMIGRATE', 'resident')#
				set(z, z[, which(TR_INMIGRATE=='inmigrant_from_external')], 'TR_COMM_TYPE', 'external')#
				z		<- subset(z, TR_COMM_TYPE==groups$TR_COMM_TYPE[ii] & TR_INMIGRATE==groups$TR_INMIGRATE[ii] & TR_SEX==groups$TR_SEX[ii])#
				z		<- z[, list(PI=sum(PI)), by=c('REC_COMM_TYPE','REC_SEX','IT')]#
				z		<- z[, list(REC_COMM_TYPE=REC_COMM_TYPE, REC_SEX=REC_SEX, PI=PI/sum(PI)), by=c('IT')]				#
				z		<- z[, list(P=qsn, Q=unname(quantile(PI, p=qs))), by=c('REC_COMM_TYPE','REC_SEX')]#
				z[, TR_COMM_TYPE:= groups$TR_COMM_TYPE[ii] ]#
				z[, TR_INMIGRATE:= groups$TR_INMIGRATE[ii] ]#
				z[, TR_SEX:= groups$TR_SEX[ii] ]#
				z#
			})#
	z		<- do.call('rbind',z)
z
z		<- dcast.data.table(z, TR_COMM_TYPE+REC_COMM_TYPE+TR_INMIGRATE+TR_SEX+REC_SEX~P, value.var='Q')#
	z[, LABEL:= paste0(round(M*100, d=1), '%\n[',round(CL*100,d=1),'% - ',round(CU*100,d=1),'%]')]#
	z[, LABEL2:= paste0(round(M*100, d=1), '% (',round(CL*100,d=1),'%-',round(CU*100,d=1),'%)')]
z
setkey(z, TR_COMM_TYPE, REC_COMM_TYPE, TR_INMIGRATE, TR_SEX)#
	z[, STAT:='waifm3']	#
	z[, DUMMY:= seq_len(nrow(z))]#
	ans		<- rbind(ans, z)
ans
groups	<- data.table(	REC_COMM_TYPE=c('inland','fisherfolk','inland','fisherfolk'),#
							REC_SEX=c('M','M','F','F'))#
	z		<- lapply(1:nrow(groups), function(ii)#
			{	#
				z		<- copy(mcpi)				#
				#	reset to complex migration status#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')	#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')					#
				set(z, z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')], 'TR_INMIGRATE', 'resident')#
				set(z, z[, which(TR_INMIGRATE=='inmigrant_from_external')], 'TR_COMM_TYPE', 'external')				#
				z		<- subset(z, REC_COMM_TYPE==groups$REC_COMM_TYPE[ii] & REC_SEX=groups$REC_SEX[ii])								#
				z		<- z[, list(PI=sum(PI)), by=c('TR_COMM_TYPE','TR_SEX','TR_INMIGRATE','IT')]#
				z		<- z[, list(TR_COMM_TYPE=TR_COMM_TYPE, TR_SEX=TR_SEX, TR_INMIGRATE=TR_INMIGRATE, PI=PI/sum(PI)), by=c('IT')]#
				z		<- z[, list(P=qsn, Q=unname(quantile(PI, p=qs))), by=c('TR_COMM_TYPE','TR_INMIGRATE','TR_SEX')]#
				z[, REC_COMM_TYPE:= groups$REC_COMM_TYPE[ii] ]#
				z[, REC_SEX:= groups$REC_SEX[ii] ]#
				z	 #
			})#
	z		<- do.call('rbind',z)#
	z		<- dcast.data.table(z, TR_COMM_TYPE+REC_COMM_TYPE+TR_INMIGRATE+TR_SEX+REC_SEX~P, value.var='Q')#
	z[, LABEL:= paste0(round(M*100, d=1), '%\n[',round(CL*100,d=1),'% - ',round(CU*100,d=1),'%]')]#
	z[, LABEL2:= paste0(round(M*100, d=1), '% (',round(CL*100,d=1),'%-',round(CU*100,d=1),'%)')]#
	setkey(z, REC_COMM_TYPE, TR_COMM_TYPE, TR_INMIGRATE, TR_SEX, REC_SEX)#
	z[, STAT:='sources3']	#
	z[, DUMMY:= seq_len(nrow(z))]
groups	<- data.table(	REC_COMM_TYPE=c('inland','fisherfolk','inland','fisherfolk'),#
							REC_SEX=c('M','M','F','F'))
groups
ii<- 1
z		<- copy(mcpi)				#
				#	reset to complex migration status#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')	#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')					#
				set(z, z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')], 'TR_INMIGRATE', 'resident')#
				set(z, z[, which(TR_INMIGRATE=='inmigrant_from_external')], 'TR_COMM_TYPE', 'external')				#
				z		<- subset(z, REC_COMM_TYPE==groups$REC_COMM_TYPE[ii] & REC_SEX=groups$REC_SEX[ii])
z		<- subset(z, REC_COMM_TYPE==groups$REC_COMM_TYPE[ii] & REC_SEX==groups$REC_SEX[ii])
z
z		<- z[, list(PI=sum(PI)), by=c('TR_COMM_TYPE','TR_SEX','TR_INMIGRATE','IT')]#
				z		<- z[, list(TR_COMM_TYPE=TR_COMM_TYPE, TR_SEX=TR_SEX, TR_INMIGRATE=TR_INMIGRATE, PI=PI/sum(PI)), by=c('IT')]#
				z		<- z[, list(P=qsn, Q=unname(quantile(PI, p=qs))), by=c('TR_COMM_TYPE','TR_INMIGRATE','TR_SEX')]#
				z[, REC_COMM_TYPE:= groups$REC_COMM_TYPE[ii] ]#
				z[, REC_SEX:= groups$REC_SEX[ii] ]#
				z
groups	<- data.table(	REC_COMM_TYPE=c('inland','fisherfolk','inland','fisherfolk'),#
							REC_SEX=c('M','M','F','F'))#
	z		<- lapply(1:nrow(groups), function(ii)#
			{	#
				z		<- copy(mcpi)				#
				#	reset to complex migration status#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				set(z, z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')], 'TR_INMIGRATE', 'resident')#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='inland' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')	#
				tmp2	<- z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_inland')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'inland')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')#
				tmp2	<- z[, which(TR_COMM_TYPE=='inland' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')]#
				set(z, tmp2, 'TR_COMM_TYPE', 'fisherfolk')#
				set(z, tmp2, 'TR_INMIGRATE', 'outmigrant')					#
				set(z, z[, which(TR_COMM_TYPE=='fisherfolk' & REC_COMM_TYPE=='fisherfolk' & TR_INMIGRATE=='inmigrant_from_fisherfolk')], 'TR_INMIGRATE', 'resident')#
				set(z, z[, which(TR_INMIGRATE=='inmigrant_from_external')], 'TR_COMM_TYPE', 'external')				#
				z		<- subset(z, REC_COMM_TYPE==groups$REC_COMM_TYPE[ii] & REC_SEX==groups$REC_SEX[ii])								#
				z		<- z[, list(PI=sum(PI)), by=c('TR_COMM_TYPE','TR_SEX','TR_INMIGRATE','IT')]#
				z		<- z[, list(TR_COMM_TYPE=TR_COMM_TYPE, TR_SEX=TR_SEX, TR_INMIGRATE=TR_INMIGRATE, PI=PI/sum(PI)), by=c('IT')]#
				z		<- z[, list(P=qsn, Q=unname(quantile(PI, p=qs))), by=c('TR_COMM_TYPE','TR_INMIGRATE','TR_SEX')]#
				z[, REC_COMM_TYPE:= groups$REC_COMM_TYPE[ii] ]#
				z[, REC_SEX:= groups$REC_SEX[ii] ]#
				z	 #
			})#
	z		<- do.call('rbind',z)#
	z		<- dcast.data.table(z, TR_COMM_TYPE+REC_COMM_TYPE+TR_INMIGRATE+TR_SEX+REC_SEX~P, value.var='Q')#
	z[, LABEL:= paste0(round(M*100, d=1), '%\n[',round(CL*100,d=1),'% - ',round(CU*100,d=1),'%]')]#
	z[, LABEL2:= paste0(round(M*100, d=1), '% (',round(CL*100,d=1),'%-',round(CU*100,d=1),'%)')]#
	setkey(z, REC_COMM_TYPE, TR_COMM_TYPE, TR_INMIGRATE, TR_SEX, REC_SEX)#
	z[, STAT:='sources3']	#
	z[, DUMMY:= seq_len(nrow(z))]
z
ans		<- rbind(ans, z)	#
	z		<- NULL#
	gc()#
	#	save#
	save(ans, file=paste0(outfile.base,'_flows_fishinlandmigrationgender.rda'))
ans
1100/1750
load(infile.inference)#
	#	thin MCMC output#
	tmp			<- seq.int(2, nrow(mc$pars$Z), mc$sweep)#
	mc$pars$S	<- mc$pars$S[tmp,,drop=FALSE]#
	mc$pars$Z	<- mc$pars$Z[tmp,,drop=FALSE]#
	mc$pars$PI	<- mc$pars$PI[tmp,,drop=FALSE]#
	mc$pars$N	<- mc$pars$N[tmp,,drop=FALSE]#
	gc()#
	colnames(mc$pars$S)	<- paste0('S-',1:ncol(mc$pars$S))#
	colnames(mc$pars$Z)	<- paste0('Z-',1:ncol(mc$pars$Z))#
	colnames(mc$pars$PI)<- paste0('PI-',1:ncol(mc$pars$PI))#
	colnames(mc$pars$N)	<- 'N'#
	#	convert to coda#
	mcc			<- mcmc( cbind( mc$pars$N, mc$pars$Z, mc$pars$PI, mc$pars$S) )#
	mcc.eff		<- effectiveSize(mcc)
require(coda)
mcc			<- mcmc( cbind( mc$pars$N, mc$pars$Z, mc$pars$PI, mc$pars$S) )#
	mcc.eff		<- effectiveSize(mcc)
mcc.eff
outfile.base
#	plot trace and autocorrelations for variable with worst 6 effective sizes#
	tmp			<- mcc.eff[mcc.eff>0] #
	tmp			<- names(tmp[sort(tmp, index.return=TRUE)$ix[1:6]])	#
	pdf(file=paste0(outfile.base,'_6worstchains_trace.pdf'), w=10, h=7)#
	plot( mcc[,tmp] )#
	dev.off()#
	pdf(file=paste0(outfile.base,'_6worstchains_autocor.pdf'), w=5, h=7)#
	autocorr.plot( mcc[,tmp] )#
	dev.off()
data.table(PAR=names(mcc.eff), NEFF=as.numeric(mcc.eff))
mcc.eff		<- data.table(PAR=names(mcc.eff), NEFF=as.numeric(mcc.eff))
mcc.eff
setkey(mcc.eff, NEFF)
mcc.eff
mcc.eff[1:100,]
mcc
str(mcc)
mc$sweep
dirname(infile.inference)
infile.participation	<- file.path(indir,"participation_differences_180322_logisticmodels.rda")
z<- load(infile.participation)
z
str(mp1)
detach(package:rethinking)
str(mp1)
detach(package::rethinking)
detach(package:rethinking)
?detach
detach(package:map2stan)
detach(package:rstan)
str(mp1)
extract.samples(mp1)
mp1@stanfit@sim
mp1@stanfit@sim$samples
str(mp1@stanfit@sim$samples)
class(mp1)
rstan::extract
indir
infile.participation	<- file.path(indir,"participation_differences_180322_logisticmodels.rda")
z<- load(infile.participation)
z
mps			<- extract.samples(mp3)
require(rethinking)
mps			<- extract.samples(mp3)
mps
str(mps)
save(dg, mps, file=file.path(indir,"participation_differences_180322_logisticmodels_samples.rda"))
infile.sequencing		<- file.path(indir,"sequencing_differences_180322_logisticmodels.rda")
z<- load(infile.sequencing)
z
mss			<- extract.samples(ms1)
save(dg, mss, file=file.path(indir,"sequencing_differences_180322_logisticmodels_samples.rda"))
infile.sequencing	<- file.path(indir,"sequencing_differences_180322_exclART_logisticmodels.rda")
z<- load(infile.sequencing)
mss			<- extract.samples(ms1)
save(dg, mss, file=file.path(indir,"sequencing_differences_180322_exclART_logisticmodels_samples.rda"))
require(Phyloscanner.R.utilities)
warnings()
?igraph.to.graphNEL
?edmondsOptimumBranching
?graph.data.frame
?sna
?get.adjacency
?kcycle.census
require(Phyloscanner.R.utilities)#
	#	setting up workspace#
	HOME			<- '~/sandbox/DeepSeqProjects'#
	indir			<- file.path(HOME, 'RakaiPopSample_phyloscanner_analysis')#
	#	load pairs and networks#
	infile.pairs	<- file.path(outdir,'phsc_analysis_of_dataset_S1_allpairs.rda')#
	infile.networks	<- file.path(outdir,'phsc_analysis_of_dataset_S1_allnetworks.rda')#
	load( infile.pairs )	# loads rtp, rplkl, rpw#
	load( infile.networks )	# loads rtn, rtnn
infile.pairs	<- file.path(indir,'phsc_analysis_of_dataset_S1_allpairs.rda')#
	infile.networks	<- file.path(indir,'phsc_analysis_of_dataset_S1_allnetworks.rda')#
	load( infile.pairs )	# loads rtp, rplkl, rpw#
	load( infile.networks )	# loads rtn, rtnn
rtn
rtnn
rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
	rtnn[, SELECT:= NA_character_]#
	set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one individual')#
	set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'ph unlinked pair')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'unclear if pair ph linked or unlinked')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'ph linked pair direction not resolved')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'ph linked pair direction 12')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'ph linked pair direction 21')
rtp
conf.cut		<- 0.6			#
	rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
	rtnn[, SELECT:= NA_character_]#
	set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one individual')#
	set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'ph unlinked pair')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'unclear if pair ph linked or unlinked')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'ph linked pair direction not resolved')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'ph linked pair direction 12')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'ph linked pair direction 21')	#
	#	add gender#
	tmp		<- subset(rtp, select=c(ID1, ID2, ID1_SEX, ID2_SEX))#
	rtnn	<- merge(rtnn, tmp, by=c('ID1','ID2'))
conf.cut		<- 0.6			#
	rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
	rtnn[, SELECT:= NA_character_]#
	set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one individual')#
	set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'ph unlinked pair')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=conf.cut)], 'SELECT', 'unclear if pair ph linked or unlinked')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut)], 'SELECT', 'ph linked pair direction not resolved')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut & POSTERIOR_SCORE_12>conf.cut)], 'SELECT', 'ph linked pair direction 12')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut & POSTERIOR_SCORE_21>conf.cut)], 'SELECT', 'ph linked pair direction 21')	#
	#	add gender#
	tmp		<- subset(rtp, select=c(ID1, ID2, ID1_SEX, ID2_SEX))#
	rtnn	<- merge(rtnn, tmp, by=c('ID1','ID2'))
infile.pairs	<- file.path(indir,'phsc_analysis_of_dataset_S1_allpairs.rda')#
	infile.networks	<- file.path(indir,'phsc_analysis_of_dataset_S1_allnetworks.rda')#
	load( infile.pairs )	# loads rtp, rplkl, rpw#
	load( infile.networks )	# loads rtn, rtnn#
	#	classify linkages#
	conf.cut		<- 0.6			#
	rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
	rtnn[, SELECT:= NA_character_]#
	set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one individual')#
	set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'ph unlinked pair')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=conf.cut)], 'SELECT', 'unclear if pair ph linked or unlinked')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut)], 'SELECT', 'ph linked pair direction not resolved')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut & POSTERIOR_SCORE_12>conf.cut)], 'SELECT', 'ph linked pair direction 12')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut & POSTERIOR_SCORE_21>conf.cut)], 'SELECT', 'ph linked pair direction 21')	#
	#	add gender#
	tmp		<- subset(rtp, select=c(ID1, ID2, ID1_SEX, ID2_SEX))#
	rtnn	<- merge(rtnn, tmp, by=c('ID1','ID2'))
rtnn
rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]
rtnn
rtnn[, table(SXO)]
infile.pairs	<- file.path(indir,'phsc_analysis_of_dataset_S1_allpairs.rda')#
	infile.networks	<- file.path(indir,'phsc_analysis_of_dataset_S1_allnetworks.rda')#
	load( infile.pairs )	# loads rtp, rplkl, rpw#
	load( infile.networks )	# loads rtn, rtnn#
	#	classify linkages#
	conf.cut		<- 0.6				#
	rtnn[, SELECT:= NA_character_]#
	set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one individual')#
	set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'ph unlinked pair')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=conf.cut)], 'SELECT', 'unclear if pair ph linked or unlinked')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut)], 'SELECT', 'ph linked pair direction not resolved')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut & POSTERIOR_SCORE_12>conf.cut)], 'SELECT', 'ph linked pair direction 12')#
	set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>conf.cut & POSTERIOR_SCORE_21>conf.cut)], 'SELECT', 'ph linked pair direction 21')	#
	#	add gender#
	tmp		<- subset(rtp, select=c(ID1, ID2, ID1_SEX, ID2_SEX))#
	rtnn	<- merge(rtnn, tmp, by=c('ID1','ID2'))
rtnn
tmp		<- subset(rtnn, ID1_SEX=='F' & ID2_SEX=='M')
tmp
setnames(tmp, colnames(tmp), gsub('xx','ID2',gsub('ID2','ID1',gsub('ID1','xx',gsub('xx','12',gsub('12','21',gsub('21','xx',colnames(tmp))))))))
tmp
set(tmp, NULL, 'SELECT', tmp[, gsub('xx','12',gsub('12','21',gsub('21','xx',SELECT)))])
tmp
rbind(subset(rtnn, !(ID1_SEX=='F' & ID2_SEX=='M')), tmp)
rtnn	<- rbind(subset(rtnn, !(ID1_SEX=='F' & ID2_SEX=='M')), tmp)
rtnn
rtnn[, PAIR_SEX:= paste0(ID1_SEX,ID2_SEX)]
rtnn
rtnn[, table(PAIR_SEX]
rtnn[, table(PAIR_SEX)]
subset(rtnn, grepl('linked',SELECT))
subset(rtnn, !grepl('unlinked|insufficient',SELECT))
rtp		<- subset(rtnn, !grepl('unlinked|insufficient',SELECT))
rtp
rtp[, table(PAIR_SEX)]
rtpd	<- subset(rtnn, ID1_SEX=='M' & ID2_SEX=='F' & grepl('direction 12|direction 21',SELECT))
rtpd
indir				<- '~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run'	#
	infiles				<- data.table(F=list.files(indir, pattern='.*_networksallpairs.rda'), CONF_CUT=0.6)#
	infiles				<- subset(infiles, !grepl('cl[0-9]+_prior',F))	#
	infiles				<- rbind(infiles, data.table(F='todi_pairs_171122_cl25_d50_prior23_min30_networksallpairs.rda', CONF_CUT=c(0.5, 0.55, 0.65, 0.7, 0.75, 0.8)))
infiles
F<- 'RakaiAll_output_170704_w250_s20_p25_d50_stagetwo_rerun23_min20_networksallpairs.rda'
infile			<- file.path(indir,F)#
				confidence.cut	<- CONF_CUT#
				cat('\nprocessing\n',infile,'\n',confidence.cut)				#
				load(infile)#
				z<-
CONF_CUT<- 0.6
infile			<- file.path(indir,F)#
				confidence.cut	<- CONF_CUT#
				cat('\nprocessing\n',infile,'\n',confidence.cut)				#
				z<- load(infile)
z
#	prepare SELECT#
				rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
				rtnn[, SELECT:= NA_character_]#
				set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one partner of couple')#
				set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'couple most likely not a pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'couple ambiguous if pair or not pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'couple most likely a pair direction not resolved')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 12')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 21')
subset(rtnn, grepl('12|21'))
subset(rtnn, grepl('12|21', SELECT))
ans	<- subset(rtnn, grepl('12|21', SELECT))
#	false discovery rate: direction#
				infile.trmpairs.todi	<- gsub('networksallpairs.rda','withmetadata.rda', infile) 										  #
				z<- load(infile.trmpairs.todi)
z
rtp
ans
ans[, table(ID1_SEX, ID2_SEX)]
infile			<- file.path(indir,F)#
				confidence.cut	<- CONF_CUT#
				cat('\nprocessing\n',infile,'\n',confidence.cut)				#
				load(infile)#
				#	prepare SELECT#
				rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
				rtnn[, SELECT:= NA_character_]#
				set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one partner of couple')#
				set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'couple most likely not a pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'couple ambiguous if pair or not pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'couple most likely a pair direction not resolved')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 12')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 21')#
				ans	<- subset(rtnn, ID1_SEX=='M' & ID2_SEX=='F' & grepl('12|21', SELECT), c(ID1,ID2))#
				setnames(ans, c('ID1','ID2'), c('MALE_RID','FEMALE_RID'))
ans
z
rto
rtp
merge(ans, rtp, by=c('MALE_RID','FEMALE_RID'))
ans	<- merge(ans, rtp, by=c('MALE_RID','FEMALE_RID'))
indir				<- '~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run'	#
	infiles				<- data.table(F=list.files(indir, pattern='.*_networksallpairs.rda'), CONF_CUT=0.6)#
	infiles				<- subset(infiles, !grepl('cl[0-9]+_prior',F))	#
	infiles				<- rbind(infiles, data.table(F='todi_pairs_171122_cl25_d50_prior23_min30_networksallpairs.rda', CONF_CUT=c(0.5, 0.55, 0.65, 0.7, 0.75, 0.8)))#
	ans					<- infiles[, {#
				infile			<- file.path(indir,F)#
				confidence.cut	<- CONF_CUT#
				cat('\nprocessing\n',infile,'\n',confidence.cut)				#
				load(infile)#
				#	prepare SELECT#
				rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
				rtnn[, SELECT:= NA_character_]#
				set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one partner of couple')#
				set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'couple most likely not a pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'couple ambiguous if pair or not pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'couple most likely a pair direction not resolved')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 12')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 21')#
				#	select male-female with direction#
				ans	<- subset(rtnn, ID1_SEX=='M' & ID2_SEX=='F' & grepl('12|21', SELECT), c(ID1,ID2))#
				setnames(ans, c('ID1','ID2'), c('MALE_RID','FEMALE_RID'))#
				#	add meta-data#
				ans	<- merge(ans, rtp, by=c('MALE_RID','FEMALE_RID'))#
				ans							#
			}, by='F']
indir				<- '~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run'	#
	infiles				<- data.table(F=list.files(indir, pattern='.*_networksallpairs.rda'), CONF_CUT=0.6)#
	infiles				<- subset(infiles, !grepl('cl[0-9]+_prior',F))	#
	infiles				<- rbind(infiles, data.table(F='todi_pairs_171122_cl25_d50_prior23_min30_networksallpairs.rda', CONF_CUT=c(0.5, 0.55, 0.65, 0.7, 0.75, 0.8)))#
	ans					<- infiles[, {#
				infile			<- file.path(indir,F)#
				confidence.cut	<- CONF_CUT#
				cat('\nprocessing\n',infile,'\n',confidence.cut)				#
				load(infile)#
				#	prepare SELECT#
				rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
				rtnn[, SELECT:= NA_character_]#
				set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one partner of couple')#
				set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'couple most likely not a pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'couple ambiguous if pair or not pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'couple most likely a pair direction not resolved')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 12')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 21')#
				#	select male-female with direction#
				ans	<- subset(rtnn, ID1_SEX=='M' & ID2_SEX=='F' & grepl('12|21', SELECT), c(ID1,ID2))#
				setnames(ans, c('ID1','ID2'), c('MALE_RID','FEMALE_RID'))#
				#	add meta-data#
				ans	<- merge(ans, rtp, by=c('MALE_RID','FEMALE_RID'))#
				ans							#
			}, by=c('F','CONF_CUT')]
ans
unique(ans, by=c('MALE_RID','FEMALE_RID'))
ans	<- unique(ans, by=c('MALE_RID','FEMALE_RID'))
ans
rca	<- copy(ans)#
	#	prepare extending serodiscordant couples	#
	rca[, EXT_TYPE:=NA_character_]#
	set(rca, rca[, which(FEMALE_LASTNEGDATE>=MALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-mf')		#
	set(rca, rca[, which(MALE_LASTNEGDATE>=FEMALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-fm')	#
	#	add extra couples in who one has CD4<400 and the other has CD4>800#
	#	for male potential recipient - evaluate CD4 around time male first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc-fm-2yrs')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc-mf-2yrs')
rca
tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc-fm-1yr')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc-mf-1yr')
set(rca, NULL, 'EXT_DIR', rca[, gsub('^([a-zA-Z0-9]+)-([a-zA-Z]+)$','\\2',EXT_TYPE)])#
	set(rca, NULL, 'EXT_TYPE', rca[, gsub('^([a-zA-Z0-9]+)-([a-zA-Z]+)$','\\1',EXT_TYPE)])
rca
rca	<- copy(ans)#
	#	prepare extending serodiscordant couples	#
	rca[, EXT_TYPE:=NA_character_]#
	set(rca, rca[, which(FEMALE_LASTNEGDATE>=MALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-mf')		#
	set(rca, rca[, which(MALE_LASTNEGDATE>=FEMALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-fm')	#
	#	add extra couples in who one has CD4<400 and the other has CD4>800#
	#	for male potential recipient - evaluate CD4 around time male first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_2yrs-fm')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_2yrs-mf')#
	#	within 1 year#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_1yr-fm')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_1yr-mf')	#
	#	separate into EXT_TYPE and EXT_DIR#
	set(rca, NULL, 'EXT_DIR', rca[, gsub('^([a-zA-Z0-9]+)-([a-zA-Z]+)$','\\2',EXT_TYPE)])#
	set(rca, NULL, 'EXT_TYPE', rca[, gsub('^([a-zA-Z0-9]+)-([a-zA-Z]+)$','\\1',EXT_TYPE)])
rca
set(rca, NULL, 'EXT_DIR', rca[, gsub('^([a-zA-Z0-9_]+)-([a-zA-Z]+)$','\\2',EXT_TYPE)])#
	set(rca, NULL, 'EXT_TYPE', rca[, gsub('^([a-zA-Z0-9_]+)-([a-zA-Z]+)$','\\1',EXT_TYPE)])
rca
rca	<- copy(ans)#
	#	prepare extending serodiscordant couples	#
	rca[, EXT_TYPE:=NA_character_]#
	set(rca, rca[, which(FEMALE_LASTNEGDATE>=MALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-mf')		#
	set(rca, rca[, which(MALE_LASTNEGDATE>=FEMALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-fm')	#
	#	add extra couples in who one has CD4<400 and the other has CD4>800#
	#	for male potential recipient - evaluate CD4 around time male first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_2yrs-fm')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_2yrs-mf')#
	#	within 1 year#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_1yr-fm')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_1yr-mf')	#
	#	separate into EXT_TYPE and EXT_DIR#
	set(rca, NULL, 'EXT_DIR', rca[, gsub('^([a-zA-Z0-9_]+)-([a-zA-Z]+)$','\\2',EXT_TYPE)])#
	set(rca, NULL, 'EXT_TYPE', rca[, gsub('^([a-zA-Z0-9_]+)-([a-zA-Z]+)$','\\1',EXT_TYPE)])
rca
rca[, PHSC_DIR:= NA_character_]#
	set(rca, rca[, which(grepl('direction resolved',SELECT) & POSTERIOR_SCORE_MF>POSTERIOR_SCORE_FM)], 'PHSC_DIR', 'mf')#
	set(rca, rca[, which(grepl('direction resolved',SELECT) & POSTERIOR_SCORE_MF<POSTERIOR_SCORE_FM)], 'PHSC_DIR', 'fm')
rca
subest(rca, !is.na(EXT_TYPE), select=c(MALE_RID, FEMALE_RID, EXT_TYPE, EXT_DIR))
subset(rca, !is.na(EXT_TYPE), select=c(MALE_RID, FEMALE_RID, EXT_TYPE, EXT_DIR))
ans	<- subset(rca, !is.na(EXT_TYPE), select=c(MALE_RID, FEMALE_RID, EXT_TYPE, EXT_DIR))
ans
indir				<- '~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run'	#
	infiles				<- data.table(F=list.files(indir, pattern='.*_networksallpairs.rda'), CONF_CUT=0.6)#
	infiles				<- subset(infiles, !grepl('cl[0-9]+_prior',F))	#
	infiles				<- rbind(infiles, data.table(F='todi_pairs_171122_cl25_d50_prior23_min30_networksallpairs.rda', CONF_CUT=c(0.5, 0.55, 0.65, 0.7, 0.75, 0.8)))#
	ans					<- infiles[, {#
				infile			<- file.path(indir,F)#
				confidence.cut	<- CONF_CUT#
				cat('\nprocessing\n',infile,'\n',confidence.cut)				#
				load(infile)#
				#	prepare SELECT#
				rtnn[, SXO:= paste0(ID1_SEX,ID2_SEX)]#
				rtnn[, SELECT:= NA_character_]#
				set(rtnn, rtnn[, which(is.na(PTY_RUN))], 'SELECT', 'insufficient deep sequence data for at least one partner of couple')#
				set(rtnn, rtnn[, which(!is.na(PTY_RUN) & is.na(LINK_12) & is.na(LINK_21))], 'SELECT', 'couple most likely not a pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED<=confidence.cut)], 'SELECT', 'couple ambiguous if pair or not pair')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut)], 'SELECT', 'couple most likely a pair direction not resolved')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_12>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 12')#
				set(rtnn, rtnn[, which(!is.na(POSTERIOR_SCORE_LINKED) & POSTERIOR_SCORE_LINKED>confidence.cut & POSTERIOR_SCORE_21>confidence.cut)], 'SELECT', 'couple most likely a pair direction resolved to 21')#
				#	select male-female with direction#
				ans	<- subset(rtnn, ID1_SEX=='M' & ID2_SEX=='F' & grepl('12|21', SELECT), c(ID1,ID2))#
				setnames(ans, c('ID1','ID2'), c('MALE_RID','FEMALE_RID'))#
				#	add meta-data#
				ans	<- merge(ans, rtp, by=c('MALE_RID','FEMALE_RID'))#
				ans							#
			}, by=c('F','CONF_CUT')]#
	ans	<- unique(ans, by=c('MALE_RID','FEMALE_RID'))
rca	<- copy(ans)#
	#	prepare extending serodiscordant couples	#
	rca[, EXT_TYPE:=NA_character_]#
	set(rca, rca[, which(FEMALE_LASTNEGDATE>=MALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-mf')		#
	set(rca, rca[, which(MALE_LASTNEGDATE>=FEMALE_FIRSTPOSDATE)], 'EXT_TYPE', 'serodisc-fm')	#
	#	add extra couples in who one has CD4<400 and the other has CD4>800#
	#	for male potential recipient - evaluate CD4 around time male first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_2yrs-fm')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which(is.na(EXT_TYPE) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<2)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_2yrs-mf')#
	#	within 1 year#
	tmp	<- rca[, which((is.na(EXT_TYPE)|grepl('CD4disc_2yrs',EXT_TYPE)) &#
							MALE_RECENTCD4>800 & abs(MALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1 &#
							FEMALE_RECENTCD4<400 & abs(FEMALE_RECENTCD4DATE-MALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_1yr-fm')#
	#	for female potential recipient - evaluate CD4 around time female first positive#
	tmp	<- rca[, which((is.na(EXT_TYPE)|grepl('CD4disc_2yrs',EXT_TYPE)) &#
							FEMALE_RECENTCD4>800 & abs(FEMALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1 &#
							MALE_RECENTCD4<400 & abs(MALE_RECENTCD4DATE-FEMALE_FIRSTPOSDATE)<1)]#
	set(rca, tmp, 'EXT_TYPE', 'CD4disc_1yr-mf')	#
	#	separate into EXT_TYPE and EXT_DIR#
	set(rca, NULL, 'EXT_DIR', rca[, gsub('^([a-zA-Z0-9_]+)-([a-zA-Z]+)$','\\2',EXT_TYPE)])#
	set(rca, NULL, 'EXT_TYPE', rca[, gsub('^([a-zA-Z0-9_]+)-([a-zA-Z]+)$','\\1',EXT_TYPE)])
rca
subset(rca, !is.na(EXT_TYPE), select=c(MALE_RID, FEMALE_RID, EXT_TYPE, EXT_DIR))
ans	<- subset(rca, !is.na(EXT_TYPE), select=c(MALE_RID, FEMALE_RID, EXT_TYPE, EXT_DIR))
setnames(ans, c('EXT_TYPE','EXT_DIR'), c('EPID_EVIDENCE_TYPE','EPID_EVIDENCE_DIR'))
ans
read.csv('~/Dropbox (SPH Imperial College)/2017_phyloscanner_validation/Supp_Data/Data_Set_S2.csv')
read.csv('~/sandbox/DeepSeqProjects/RakaiPopSample_data/Dataset_S2.csv')
dfa			<- as.data.table(read.csv("~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run/todi_pairs_171122_cl25_d50_prior23_min30_anonymised_RIDs.csv"))
dfa
unique(subset(dfa, select=c(ID, AID)))
dfa			<- unique(subset(dfa, select=c(ID, AID)))
setnames(dfa, c('ID','AID'), c('MALE_RID','MALE_ID'))
dfa
ans
merge(ans, dfa, by='MALE_RID')
ans			<- merge(ans, dfa, by='MALE_RID')
ans
setnames(dfa, c('MALE_RID','MALE_ID'), c('FEMALE_RID','FEMALE_ID'))#
	ans			<- merge(ans, dfa, by='FEMALE_RID')
ans
subset(ans, select=c(MALE_ID, FEMALE_ID, EPID_EVIDENCE_TYPE, EPID_EVIDENCE_DIR))
outfile		<- '~/sandbox/DeepSeqProjects/RakaiPopSample_data/Dataset_S3.csv'
write.csv(ans, row.names=FALSE, file=outfile)
infile		<- '~/sandbox/DeepSeqProjects/RakaiPopSample_data/Dataset_S3.csv'#
	red			<- as.data.table(read.csv(infile))
red
rtpd
set(rtpd, NULL, 'SELECT', rtpd[, gsub('ph linked pair direction 21','fm',gsub('ph linked pair direction 12','mf',SELECT))])
rtpd
setnames(rtpd, 'SELECT', 'PHYSCANNER_DIR')
rtpd
red
ans
write.csv(subset(ans, select=c(MALE_ID, FEMALE_ID, EPID_EVIDENCE_TYPE, EPID_EVIDENCE_DIR)), row.names=FALSE, file=outfile)
infile		<- '~/sandbox/DeepSeqProjects/RakaiPopSample_data/Dataset_S3.csv'#
	red			<- as.data.table(read.csv(infile))
red
setnames(red, c('MALE_ID','FEMALE_ID'), c('ID1','ID2'))
red
rtpd
rtpd	<- subset(rtpd, select=c(ID1, ID2, PHYSCANNER_DIR))
rtpd
merge(rtpd, red, by=c('ID1','ID2'))
rtpd		<- merge(rtpd, red, by=c('ID1','ID2'))
rtpd
rtpd[, PHYSCANNER_DIR_CONSISTENT:= as.integer(PHYSCANNER_DIR==EPID_EVIDENCE_DIR)]
rtpd
rtpd[, table(PHYSCANNER_DIR_CONSISTENT)]
rtnn[, table(SELECT)]
red
roxygen2::roxygenize("/Users/Oliver/git/Phyloscanner.R.utilities")
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
roxygen2::roxygenize("/Users/Oliver/git/Phyloscanner.R.utilities")
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
roxygen2::roxygenize("/Users/Oliver/git/Phyloscanner.R.utilities")
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
?system
roxygen2::roxygenize("/Users/Oliver/git/Phyloscanner.R.utilities")
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
roxygen2::roxygenize("/Users/Oliver/git/Phyloscanner.R.utilities")
roxygen2::roxygenize("/Users/Oliver/git/Phyloscanner.R.utilities")
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
require(pkgdown)#
	setwd('~/git/Phyloscanner.R.utilities')	#
	pkgdown::build_site()
0.6 * c(0.9, 0.1)
0.4 * c(0.9, 0.1)
0.6 * c(0.8, 0.3)
0.6 * c(0.8, 0.2)
0.4 * c(0.8, 0.2)
